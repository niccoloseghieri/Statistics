# This script emulate section 2. Combining Two Or More Estimates For The Same Quantity
# from the paper by: Thomas Struppeck, "Combining Estimates"

# In particular the general case with more than 2 estimators
# Here we use 4 estimators to give an idea

# Sets the R working directory to the directory where the currently active document in RStudio
# is located
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) 

# Load the global variables and functions to make plots and computations   
source("global_variables_1.r")
source("plot_functions_1.r")
source("functions_1.r")
source("generate_samples_functions_1.r")

# Margin c(bottom, left, top, right)
par(mar=c(4,4,1,1)) 

# Check if the "Plot" directory exists, and if not, create it
if (!dir.exists("Plot")) {
  dir.create("Plot")
}

# Generate the four distributions for the specified parameters
estimators_A <- generate(n, mean_A, sd_A)
estimators_B <- generate(n, mean_B, sd_B)
estimators_D <- generate(n, mean_D, sd_D)
estimators_E <- generate(n, mean_E, sd_E)

# Create a dataframe
df <- data.frame(estimators_A, estimators_B, estimators_D, estimators_E)

# Create the vector of variances
variances <- c(sd_A, sd_B, sd_D, sd_E)^2
variances

# Call the function to obtain the weights (and show them)
weight <- get_weights(variances)

# Obtain the combined estimators
combined_estimator <- get_combined(df, weight)

# Calculate the mean and the standard error of Estimators C (the combined one)
mean_C <- mean(combined_estimator)
sd_C <- sd(combined_estimator)

# Display the mean and sd
cat("Mean of estimators C -->", round(mean_C, 2))
cat("Sd of estimators C -->", round(sd_C, 2))

# Add to dataframe the combined estimator
df$combined_estimators <- combined_estimator 

# Convert the dataframe in a list and re-assign the name
df <- as.list(df)
names(df) <- c("A", "B", "D", "E", "C")

# Obtain the 95 c.i, for all the estimators
positions <- c(0.025, 0.975)

list_ci <- lapply(df, function(x) quantile(x, positions))

# Display the distributions
colors <- c("red", "blue", "black", "green", "purple", "orange")
display_distributions(df, list_ci, colors)
# Save the plot generated by display_distributions
png(file = "Plot/display_distributions_IVW.png")
display_distributions(df, list_ci, colors)
dev.off()

# Define a list containing the means
mean_list <- list(mean_A, mean_B, mean_C, mean_D, mean_E)
names(mean_list) <- c("A", "B", "C", "D", "E")

# Defined a space of hypothetical parameters for the means within the c.i.
true_params <- c(min(unlist(list_ci)),max(unlist(list_ci)))

# Obtain a list of distances
distances <- get_distances(mean_list, true_params)

# Return the intervals for which estimators E is the best
best_C_intervals = get_best_intervals(true_params, distances, "C")

# Visualize when C is the best estimator
visualize_best_intervals(true_params, distances, "C")
# Save the plot generated by visualize_best_C
png(file = "Plot/visualize_best_IVW.png")
visualize_best_intervals(true_params, distances, "C")
dev.off()

# Return the area where it is the best
lower <- best_C_intervals[1]
upper <- best_C_intervals[2]

area <- area_between(lower, upper, mean_C, sd_C)

cat("Density between the interval --> ", round(area,2))

# Clear the workspace
rm(list=ls())