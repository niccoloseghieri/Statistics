# This script emulate section 2. Combining Two Or More Estimates For The Same Quantity
# from the paper by: Thomas Struppeck, "Combining Estimates"

# In particular it shows that when estimators are 100% correlated there's no increase in
# the precision in the combined one
# It also contains a second part simulating the results for different correlations coefficients

# Sets the R working directory to the directory where the currently active document in RStudio
# is located
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) 

# Load the global variables and functions to make plots and computations   
source("global_variables_1.r")
source("plot_functions_1.r")
source("functions_1.r")
source("generate_samples_functions_1.r")

# Load the library MASS for mvrnorm
library(MASS)

# Margin c(bottom, left, top, right)
par(mar=c(4,4,1,1)) 

# Check if the "Plot" directory exists, and if not, create it
if (!dir.exists("Plot")) {
  dir.create("Plot")
}

# Estimators_B is simply estimators_A plus a constant to make A and B trivially 100% correlated
estimators_A <- generate(n, mean_A, sd_A)
estimators_B <- estimators_A + constant

# Calculate the standard deviation for the new estimators B
mean_B <- mean(estimators_B)
sd_B <- sd(estimators_B)

# Showing the correlation (equal to 1)
corr_AB <- cor(estimators_A, estimators_B)
cat("Correlation between estimator A and estimator B -->",corr_AB)

# Find the optimal weight to combine the two estimators 
weight <- optimize(var_to_opt, interval = c(0, 1), sd_a = sd_A, sd_b = sd_B)
weight <- weight$minimum 
cat("Best weight -->", weight)

# Plot the curve for each possible weight
visualize_opt(weight)
# Save the plot generated by visualize_opt
png(file = "Plot/visualize_opt_correlation.png")
visualize_opt(weight)
dev.off()

# Weighted estimators C from the previous one
estimators_C <- (1 - weight) * estimators_A + weight * estimators_B

# Calculate the mean and the standard error of Estimators C
mean_C <- mean(estimators_C)
sd_C <- sd(estimators_C)

# Display the results
cat("Mean of estimators C -->", round(mean_C, 2))
cat("Sd of estimators C -->", round(sd_C, 2))

# Put the three estimators in a list
list_est <- list("A" = estimators_A, "B" = estimators_B, "C" = estimators_C)

# Find the 95% c.i. for all the three distributions
positions <- c(0.025, 0.975)

list_ci <- lapply(list_est, function(x) quantile(x, positions))

# Define names for the elements
names(list_ci) <- c("Estimator A", "Estimator B", "Estimator C")

# Plot the estimators' distributions
colors <- c("red", "blue", "black")
display_distributions(list_est, list_ci, colors)
# Save the plot generated by display_distributions
png(file = "Plot/display_distributions_corr.png")
display_distributions(list_est, list_ci, colors)
dev.off()

# Showing that the estimators have the same sd (approximately)
cat(sprintf("Estimator A: %.2f\n", sd_A))
cat(sprintf("Estimator B: %.2f\n", sd_B))
cat(sprintf("Estimator C: %.2f\n", sd_C))

# Define a list containing the means
mean_list <- list(mean_A, mean_B, mean_C)
names(mean_list) <- c("A", "B", "C")

# Defined a space of hypothetical parameters for the means within the c.i.
true_params <- c(min(unlist(list_ci)),max(unlist(list_ci)))

# Obtain a list of distances
distances <- get_distances(mean_list, true_params)

# Return the intervals for which estimators C is the best
best_C_intervals <- get_best_intervals(true_params, distances, "C")

# Visualize when C is the best estimator
visualize_best_intervals(true_params, distances, "C")
# Save the plot generated by visualize_best_C
png(file = "Plot/visualize_best_C_corr.png")
visualize_best_intervals(true_params, distances, "C")
dev.off()

# Return the area
lower <- best_C_intervals[1]
upper <- best_C_intervals[2]

area <- area_between(lower, upper, mean_C, sd_C)

cat("Density between the interval --> ", round(area,2))


###### Simulating different correlations coefficients ##########

# Below we simulate different correlations coefficients using the means and sds from the paper
# for estimators A and estimators B showing what happens to the precision of the combined one

# Define a sequence of correlations from -1 to 1 with a step of 0.1
correlations <- seq(-1, 1, 0.1)

# Calculate variances for estimators A and estimators B from the the sds in the paper
var_A <- 30^2
var_B <- 40^2

# Create a vectors containing the means 
means <- c(mean_A, mean_B)

# Create an empty list: we will put here the estimators C obtained by:
# - correlation -1
# - correlation  0
# - correlation  1
est_C <- list()

for (corr in correlations){
  
  # Generate data for the corresponding correlation = corr
  data <- generate_data(var_A, var_B, corr, means)
  
  # Extract the two estimators from the dataframe
  estimator_A <- data$Estimators_A
  estimator_B <- data$Estimators_B
  
  # Calculate the sds
  sd_A <- sd(estimator_A)
  sd_B <- sd(estimator_B)
  
  # Calculate the best weight and extract it
  weight <- optimize(var_to_opt, interval = c(0, 1), sd_a = sd_A, sd_b = sd_B)
  weight <- weight$minimum 
  
  # Obtain estimators C
  estimator_C <- (1 - weight) * estimator_A + weight * estimator_B
  
  # Calculate the sd for estimators C
  sd_C <- sd(estimator_C)
  
  # Calculate the best standard deviation and the distance from sd for estimator C
  best_sd <- min(c(sd_A, sd_B))
  distance <- best_sd - sd_C
  
  # Print the results in a nicely formatted way
  cat("-----------------------------------------------\n")
  cat(sprintf("Correlation equal to: %0.2f\n", corr))
  cat(sprintf("SD_C --> %0.2f\n", sd_C))
  cat(sprintf("Best SD --> %0.2f\n", best_sd))
  cat(sprintf("Distance from the best --> %0.2f\n", distance))
  cat("-----------------------------------------------\n")
  
  # if the correlations is -1, 0 or 1 append estimators C to the list
  if(corr %in% c(-1,0,1)){
    est_C <- append(est_C, list(estimator_C))
  }
}

# Assign names to the list obtained
names(est_C) <- c("C (-1)", "C (0)", "C (1)")

# Find the 95% c.i. for all the three distributions
positions <- c(0.025, 0.975)

list_ci <- lapply(est_C, function(x) quantile(x, positions))

# Plot the estimators' distributions
colors <- c("red", "blue", "black")
display_distributions(est_C, list_ci, colors)
# Save the plot generated by display_distributions
png(file = "Plot/display_distributions_DifferentCorr.png")
display_distributions(est_C, list_ci, colors)
dev.off()

# Clear the workspace
rm(list=ls())